(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return d}));var a=n(2),o=n(6),r=(n(0),n(99)),i={id:"di_ingestiontypes",title:"DI - Ingestion Types",sidebar_label:"Ingestion Types"},s={unversionedId:"di_ingestiontypes",id:"di_ingestiontypes",isDocsHomePage:!1,title:"DI - Ingestion Types",description:"As part of building a data ingestion process couple of things are important. What and how do you want to maintain your data in the warehouse. Do you need the complete history? or do you need only the updated records? Answering these questions can go a long way in various use cases. We have thought about it and have consolidated into three types of ingestion. Based on your business requirements, you can choose anything among this three ingestion types for each table in your process.",source:"@site/docs/di_ingestiontypes.md",slug:"/di_ingestiontypes",permalink:"/documentation/docs/di_ingestiontypes",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/di_ingestiontypes.md",version:"current",sidebar_label:"Ingestion Types",sidebar:"someSidebar",previous:{title:"DI - System Configurations",permalink:"/documentation/docs/di_addconnection"},next:{title:"DQ - Introduction",permalink:"/documentation/docs/dq_intro"}},l=[{value:"Full Load",id:"full-load",children:[]},{value:"Incremental",id:"incremental",children:[]},{value:"Master SCD",id:"master-scd",children:[]}],c={rightToc:l};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"As part of building a data ingestion process couple of things are important. What and how do you want to maintain your data in the warehouse. Do you need the complete history? or do you need only the updated records? Answering these questions can go a long way in various use cases. We have thought about it and have consolidated into three types of ingestion. Based on your business requirements, you can choose anything among this three ingestion types for each table in your process."),Object(r.b)("h2",{id:"full-load"},"Full Load"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Full")," ingestion type can be selected if you want your target tables to be refreshed every day or as per your schedule. While performing this type of load, remember the process would truncate the data in the existing table and will load the new data. In this case the process would read the entire source table/file and will refresh the data in the target table. Important point to note here is that the target table will not have any history data in it. "),Object(r.b)("h2",{id:"incremental"},"Incremental"),Object(r.b)("p",null,"Select ",Object(r.b)("inlineCode",{parentName:"p"},"Incremental")," ingestion type when you want to pull and load only the delta records from source. Generally this type of process would be ideal for the transaction tables. In  order for the framework to successfully execute this type of ingestion two very important information is required."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"CDC Columns")," These are the column names from the source tables that will be used to find the updated and new records(Delta records) in the source every time the process runs. In general the CDC column would ideally be of type ",Object(r.b)("inlineCode",{parentName:"p"},"timestamp")," or can also be a combination of multiple columns. The new records will be inserted and the updated records will be updated in the target. For the first time execution, all the data will be pulled from the source.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"SCD Columns")," So we now have the information of what data we need to pull using the ",Object(r.b)("strong",{parentName:"p"},"CDC columns"),". Now the process needs to know how it wants to load the data into the target table. For this very reason the ",Object(r.b)("strong",{parentName:"p"},"SCD Columns")," are required. These are the source column names that will be used to perform the SCD logic. As you may be aware SCD is Slowly changing dimensions which in most cases used to capture and maintain the history and lineage of the data. ")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"SCD Type")," What type of SCD do we need to perform? Choose between ",Object(r.b)("inlineCode",{parentName:"p"},"Type 1")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Type 2"),". In most cases these are used for maintaining the history of the dimension tables. If no SCD is required, select ",Object(r.b)("inlineCode",{parentName:"p"},"None"),"."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Type 1 - Update records directly, there is no record of historical values, only current state is maintained"),Object(r.b)("li",{parentName:"ul"},"Type 2 - Track changes as version records with current flag & active dates.")))),Object(r.b)("p",null,"When performing SCD Type 2, It is required that the target table has three SCD specific columns namely ",Object(r.b)("inlineCode",{parentName:"p"},"Active_Indicator"),", ",Object(r.b)("inlineCode",{parentName:"p"},"Start_timestamp")," and ",Object(r.b)("inlineCode",{parentName:"p"},"End_timestamp")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Active_Indicator - This is the field that would indicate if that version of record is active or inactive."),Object(r.b)("li",{parentName:"ul"},"Start_timestamp - This field holds a timestamp at which the records was activated"),Object(r.b)("li",{parentName:"ul"},"End_timestamp  - This field holds a timestamp at which the record was changed or inactivated.")),Object(r.b)("p",null,"When the target table is to be created for the first time through the process, the framework would take care of creating the tables with the above three fields."),Object(r.b)("p",null,"Note: The above mentioned column names are just example. The names can be anything but the functionality of the columns should be for the reasons outlined above."),Object(r.b)("h2",{id:"master-scd"},"Master SCD"),Object(r.b)("p",null,"Select ",Object(r.b)("inlineCode",{parentName:"p"},"Master SCD")," ingestion type if you need a ",Object(r.b)("inlineCode",{parentName:"p"},"lineage key")," also to be included in the target table. Apart from adding the lineage everything is same as performing SCD type 2. "))}d.isMDXComponent=!0},99:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),d=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},h=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,b=u["".concat(i,".").concat(h)]||u[h]||p[h]||r;return n?o.a.createElement(b,s(s({ref:t},c),{},{components:n})):o.a.createElement(b,s({ref:t},c))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);